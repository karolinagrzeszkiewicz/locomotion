## Copyright Mechanisms Underlying Behavior Lab, Singapore
## https://mechunderlyingbehavior.wordpress.com/

## curve_gen.py is part of the locomotion package comparing animal behaviours, developed
## to support the work discussed in the paper "Computational geometric tools for
## modeling inherent variability in animal behavior" by MT Stamps, S Go, and AS Mathuru.

## This python script contains methods capturing and comparing randomly generated curves
## from curve_gen.py. The mathematical basis for this curve generation is described in
## the paper "Random space and plane curves" by Igor Rivin, which can be accessed here:
## https://arxiv.org/pdf/1607.05239.pdf. This script first extracts the coefficients from
## the files generated by curve_gen.py. It then generates the plane curves with coordinates 
## [x(theta), y(theta)] and captures it based on the given frame rates and pixel density.
## After capturing these test files, we run robustness tests using the locomotion package.

############# FOR ZHONGXUAN ###################### --- add on or edit the above with more details if you want!


import os
import sys
import json
import math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

sys.path.append(os.path.dirname(os.path.dirname(os.getcwd())))
import locomotion

PATH_TO_DATA_DIRECTORY = os.getcwd() + "/data"
try: # Safety check to ensure that data folder exists, and makes it otherwise.
    os.mkdir(PATH_TO_DATA_DIRECTORY)
except FileExistsError:
    pass

PATH_TO_RES_DIRECTORY = os.getcwd() + "/results"
try: # Safety check to ensure that results folder exists, and makes it otherwise.
    os.mkdir(PATH_TO_RES_DIRECTORY)
except FileExistsError:
    pass

PATH_TO_FIG_DIRECTORY = os.getcwd() + "/figures"
try: # Safety check to ensure that figures folder exists, and makes it otherwise.
    os.mkdir(PATH_TO_FIG_DIRECTORY)
except FileExistsError:
    pass


#static variables used for robustness testing
NUM_CURVES = 50 # This must match the number of curves in the data/curve_data directory.
ZFILL_LEN = int(np.ceil(np.log10(NUM_CURVES)))
NUM_SAMPLES = 50 # Number of samples being tested
SAMP_FILL = int(np.ceil(np.log10(NUM_SAMPLES)))
DEFAULT_START = 0 # Start Time in Minutes
DEFAULT_STOP = 1 # Stop Time in Minutes
FILEPATH_PREFIX_LEN = len(os.getcwd()) + len("/data/curve_data/coefficients_")

########################################################################
#### Functions for getting curve data  ####
########################################################################

def genTrigFun(a_k, b_k):
    """ Generates the Fourier series function f(theta) = sum_0^k (a_k * cos(k * theta) + b_k * sin(k * theta))
        based on the given coefficient sequences.

        :Parameters:
            a_k/b_k : float list. Coefficient sequences of length k.

        :Returns:
            function f(theta), which is defined by f(theta) = sum_0^k (a_k * cos(k * theta) + b_k * sin(k * theta)).
    """

    #define the function we want to return
    def fun_theta (theta):
        #initialise the sum of all k terms
        cum_sum = 0

        #add each term of the function to the sum iteratively
        for i in range(len(a_k)):
            cum_sum += a_k[i] * np.sin(i * theta) + b_k[i] * np.cos(i * theta)
        return cum_sum

    return (fun_theta)

def changePixDensity(num, density):
    """ ############# FOR ZHONGXUAN ######################

        :Parameters:
            num : float. ############# FOR ZHONGXUAN ######################
            density: int. ############# FOR ZHONGXUAN ######################

        :Returns:
            int. ############# FOR ZHONGXUAN ######################
    """
    #initialise return value
    result = 0

    #if our values aren't edge cases, return the corresponding value discretised to the given pixel density
    if not (num == 0 or density == 0 or math.isnan(num) or math.isnan(density)):
        result = math.floor(num * density)

    return result


def genVariables(low, high, n):
    """ Uniformly samples n values from given interval.

        :Parameters:
            low : float. Lower bound of interval.
            high : float. Upper bound of interval.
            n : int. Number of samples.

        :Returns:
            list of n floats. The uniformly sampled values within the interval.
    """
    return list(np.random.uniform(low, high, n))

########################################################################
#### Capturing curves from given frame rate/resolution  ####
########################################################################


def cameraFunc(coeff_path, time_start, time_stop, frame_rate, density, plot=False):
    """ Given a path to coefficients for the plane curve and other necessary information, ....

        :Parameters:
            coeff_path : string. Path to coefficients_xx.csv for the curve we want to capture.
            time_start, time_stop : floats. Beginning and end times to generate time step increments.
            frame_rate : int. Number of frames per second. Used to generate the time step increments.
            density : int. Pixel density. Used to convert from (############# FOR ZHONGXUAN ##############) to pixels  

        :Returns:
            tuple of dataframes (coordinates, summaryStats). 
            dataframe with columns [X, Y].
    """
    #read in data from the corresponding coefficients csv file
    data = pd.read_csv(coeff_path)

    #get curve number from the path
    curve_no = coeff_path[FILEPATH_PREFIX_LEN : FILEPATH_PREFIX_LEN + 2]

    #coefficients - each are sequences of length k
    #a_k, b_k are used for x(theta) and c_k, d_k are used for y(theta)
    a_k = data['a_k'].values
    b_k = data['b_k'].values
    c_k = data['c_k'].values
    d_k = data['d_k'].values

    #extras
    #theta value for input into the trig function
    theta = data['extras'][0]
    #size is the full dimensions of the camera, whereas x/y min/max/diff are the corresponding
    #dimensions for the bounding box that will contain the curve
    size = data['extras'][1]
    x_min = data['extras'][2]
    x_max = data['extras'][3]
    x_diff = x_max - x_min
    y_min = data['extras'][4]
    y_max = data['extras'][5]
    y_diff = y_max - y_min

    #original time increments, based on the given start/end times and frame rate
    time_t = np.arange(time_start, time_stop, 1 / frame_rate)
    ############# FOR ZHONGXUAN ###################### ----- what does 'p' stand for?
    #normalised and transformed time increments, which start at 0 and are scaled by theta
    p_time_t = theta * (time_t - time_start) / (time_stop - time_start)
    ############# FOR ZHONGXUAN ###################### ------ for clarity, it might be nice to have an explicit comment of where we convert
                                                              # theta in [0, 2pi] to time t in [0, infty) and rename variables to fit this

    #generate trig functions for x, y coordinates. Each function's domain is theta in [0, 2pi]
    x_fun = genTrigFun(a_k, b_k)
    y_fun = genTrigFun(c_k, d_k)

    #get minimum and maximum x, y coordinates of the graph 
    x_og = x_fun(p_time_t) # 1 x len(TIME_T)
    y_og = y_fun(p_time_t) # 1 x len(TIME_T)
    lower_xlim = min(x_og)
    upper_xlim = max(x_og)
    lower_ylim = min(y_og)
    upper_ylim = max(y_og)

    ############# FOR ZHONGXUAN ######################
    #transform the coordinates to fit the bounding box we set for it (scaling it to size)
    x_enlarged = []
    y_enlarged = []
    for i in range(0, len(time_t)):
        x_enlarged.append((x_diff / (upper_xlim - lower_xlim) * (x_og[i] - lower_xlim) + x_min))
        y_enlarged.append((y_diff / (upper_ylim - lower_ylim) * (y_og[i] - lower_ylim) + y_min))

    ############# FOR ZHONGXUAN ######################
    #transform coordinates based on density to fit the pixel density we assigned to it
    x = []
    y = []
    for i in range(0, len(time_t)):
        x.append(changePixDensity(x_enlarged[i], density))
        y.append(changePixDensity(y_enlarged[i], density))

    ############# FOR ZHONGXUAN ###################### ---- I changed the plotting to save to files instead of viewing
                                                          # The window size looks off though? Not sure why the curve keeps getting cut off

    if plot:
        # Plots the X, Y coordinates and coefficients of each graph and saves it into the figures folder
        plt.subplots_adjust(left = None, bottom = None, right = None, top = None, wspace = 0.5, hspace = 0.5)
        plt.subplot(121)
        plt.plot(x, y)
        plt.title("Coordinate plot for Curve No. " + curve_no)
        plt.axis([0, size, 0, size])
        plt.subplot(122)
        kSeq = np.arange(0, len(a_k), 1)
        plt.plot(kSeq, a_k)
        plt.plot(kSeq, b_k)
        plt.plot(kSeq, c_k)
        plt.plot(kSeq, d_k)
        plt.title("Coefficients of Curve No. " + curve_no)
        plt.axis([0, 20, -1, 1])
        plt.savefig(PATH_TO_FIG_DIRECTORY + "/plot_" + curve_no)
        plt.clf()

    # Transform data into dataframe
    data = np.transpose(np.array((x, y)))
    coordinates = pd.DataFrame(data, columns = ['X', 'Y'])
    summaryStats = coordinates.describe()
    return coordinates, summaryStats

########################################################################
#### Robustness Testing Setup ####
########################################################################

############# FOR ZHONGXUAN ###################### ---- maybe make the plots part of the parameters for this function??
def captureOneCurve(dat_path, curve_str, test_str, coeff_path, frame_rate, density, control = "False"):
    # Generate Capture Data
    df, _ = cameraFunc(coeff_path, DEFAULT_START * 60, DEFAULT_STOP * 60, frame_rate, density, plot = False)
    # Save Capture Data to CSV
    df.to_csv(dat_path)
    jsonItem = {
        "name": "CRV_{}_TEST_{}".format(curve_str, test_str),
        "data_file_location": dat_path,
        "animal_attributes":
            {
                "species": "Magic Scoliosis Fish",
                "exp_type": "MCS",
                "ID": curve_str,
                "control_group": control
            },
            "capture_attributes":
            {
                "dim_x": 100,
                "dim_y": 100,
                "pixels_per_mm": density,
                "frames_per_sec": frame_rate,
                "start_time": DEFAULT_START,
                "end_time": DEFAULT_STOP,
                "baseline_start_time": DEFAULT_START,
                "baseline_end_time": DEFAULT_STOP
            }
    }
    return jsonItem

############# FOR ZHONGXUAN ######################
def captureAllCurves(test_key):
    # Check / Create directory
    resultPath = PATH_TO_RES_DIRECTORY + "/" + test_key
    try:
        os.mkdir(resultPath)
    except FileExistsError:
        pass
    for curve_no in range(NUM_CURVES):
        curve_str = str(curve_no).zfill(ZFILL_LEN)
        jsonItems = []
        coeff_path = PATH_TO_DATA_DIRECTORY + "/curve_data/coefficients_{}.csv".format(curve_str)
        # Capture Control + Key Check
        try:
            control_fr, control_dens = testData[test_key]["control"]
        except KeyError:
            raise Exception("test_key not in testData")
        control_dat = resultPath + "/CRV_{}_TEST_CTRL.dat".format(curve_str)
        control_json = captureOneCurve(control_dat, curve_str, "CTRL", coeff_path, control_fr, control_dens, "True")
        jsonItems.append(control_json)
        # Capture test curves
        i = 0
        for fr in testData[test_key]["framerates"]:
            for dens in testData[test_key]["densities"]:
                test_str = str(i).zfill(SAMP_FILL)
                dat_path = resultPath + "/CRV_{}_TEST_{}.dat".format(curve_str, test_str)
                jsonItem = captureOneCurve(dat_path, curve_str, test_str, coeff_path, fr, dens)
                jsonItems.append(jsonItem)
        outfilename = resultPath + "/CRV_{}.json".format(curve_str)
        jsonstr = json.dumps(jsonItems, indent = 4)
        with open(outfilename, "w") as outfile:
            outfile.write(jsonstr)
        print("Wrote the information into %s" % outfilename)
    # Save Frame Rate data and Density data
    with open(resultPath + "/Results_variables.json", "w") as outfile:
        varJson = json.dumps(testData[test_key])
        outfile.write(varJson)


def runRobustnessTest(test_key, variables, norm_mode, start_min, end_min):
    NUM_TESTS = len(testData[test_key]["framerates"]) * len(testData[test_key]["densities"])
    results = np.zeros([NUM_CURVES, NUM_TESTS])
    for curve_no in range(NUM_CURVES):
        curve_str = str(curve_no).zfill(ZFILL_LEN)
        json_path = PATH_TO_RES_DIRECTORY + "/{}/CRV_{}.json".format(test_key, curve_str)
        # Load all animals
        animals = locomotion.getAnimalObjs(json_path)
        for a in animals:
            locomotion.trajectory.getCurveData(a)
        # Run BDD against control animal (index 0)
        control = animals[0]
        for a_no, a in enumerate(animals[1:]):
            bdd = locomotion.trajectory.computeOneBDD(a, control, variables,
                                                      start_min, end_min,
                                                      start_min, end_min,
                                                      norm_mode)
            results[curve_no][a_no] = bdd
    output = PATH_TO_RES_DIRECTORY + "/{}/Results_BDD.csv".format(test_key)
    pd.DataFrame(results).to_csv(output, index = False)

################################################################################
### Testing Space
################################################################################

 ############# FOR ZHONGXUAN ######################

testData = {
    "FR_test_lower" : {
        "framerates" : list(range(6,24)),
        "densities" : [2],
        "control" : (24, 2)
    },
    "FR_test_higher" : {
        "framerates" : list(range(24,120,2)),
        "densities" : [2],
        "control" : (24, 2)
    },
    "density_test_lower" : {
        "framerates" : [24],
        "densities" : genVariables(0.5, 2, NUM_SAMPLES),
        "control" : (24, 2)
    },
    "density_test_higher" : {
        "framerates" : [24],
        "densities" : genVariables(2, 8, NUM_SAMPLES),
        "control" : (24, 2)
    }
}

############# FOR ZHONGXUAN ######################


# Change these variables
test_name = "FR_test_higher"
test_variables = ['Velocity', 'Curvature']
test_norm_mode = 'spec'

captureAllCurves(test_name) # Uncomment to recapture curves
runRobustnessTest(test_name, test_variables, test_norm_mode, DEFAULT_START, DEFAULT_STOP)
